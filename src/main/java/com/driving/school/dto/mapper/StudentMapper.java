package com.driving.school.dto.mapper;

import com.driving.school.dto.*;
import com.driving.school.model.Student;
import org.mapstruct.Mapper;
import org.mapstruct.Mapping;
import org.mapstruct.MappingTarget;
import org.mapstruct.NullValuePropertyMappingStrategy;


/**
 * Maps between various StudentDTOs and the Student entity.<br>
 * <br>
 * This abstract class will be automagically extended by MapStruct. Only the 'abstract' methods are auto-generated, the
 * concrete implementations are needed for type-casting.
 */
@Mapper(nullValuePropertyMappingStrategy = NullValuePropertyMappingStrategy.IGNORE)
public abstract class StudentMapper implements GenericMapper<Student> {
    @Override
    public abstract StudentResponseDto toResponseDto(Student student);


    /**
     * Casts the requestData to the appropriate DTO type and then calls an autogenerated MapStruct mapping method to
     * convert it to a new Student entity.<br><br> The cast is required because MapStruct is a compile-time processor
     * and is not aware of run-time types, so it can't perform the cast dynamically. It could be enforced by the
     * `@SubclassMapping` annotation, but sadly that's not supported for Update methods, so instead this approach was
     * chosen for consistency.
     *
     * @param requestData <code>StudentCreationDto</code> source of data
     * @return a new <code>Student</code> entity
     */
    @Override
    public Student toModel(CreationDto requestData) {
        ifNotInstanceThrow(requestData, StudentCreationDto.class);
        StudentCreationDto source = (StudentCreationDto) requestData;

        return createEntity(source);
    }

    /**
     * Casts the requestData to the appropriate DTO type and then calls an autogenerated MapStruct mapping method to
     * overwrite the fields of the Student destination, without creating a new entity. Any <code>null</code> values in
     * the requestData will be skipped.<br><br> The cast is required because MapStruct is a compile-time processor and
     * is not aware of run-time types, so it can't perform the cast dynamically. Note that @SubclassMapping is not
     * supported for Update methods.
     *
     * @param destination a Student entity that should be modified
     * @param requestData a StudentUpdateDto with some (or all) updated field values
     */
    @Override
    public void updateFields(Student destination, UpdateDto requestData) {
        ifNotInstanceThrow(requestData, StudentUpdateDto.class);
        StudentUpdateDto source = (StudentUpdateDto) requestData;

        patchEntity(destination, source);
    }

    // TODO done like this for testing, we should probably define default values in the Entity itself
    // (except maybe 'id')
    @Mapping(target = "id", constant = "0L")
    @Mapping(target = "blocked", constant = "false")
    @Mapping(target = "accountBalance", constant = "0")
    @Mapping(target = "lessonMinutesLeft", constant = "1800")
    protected abstract Student createEntity(StudentCreationDto source);

    protected abstract void patchEntity(@MappingTarget Student destination, StudentUpdateDto source);
}
